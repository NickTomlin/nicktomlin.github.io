<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>VimL Functions</title><meta name="description" content="I'm Nick Tomlin, a full stack engineer that loves JavaScript and poetry."><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=Rubik:ital,wght@0,400;0,500;0,600;0,700;1,400&display=swap" rel="stylesheet"><link rel="stylesheet" href="/_astro/about.Mng-hDlY.css"></head> <body> <header class="relative my-4"> <div class="wrapper flex items-center justify-between site-header"> <div class="mt-2"> <a href="/"><img class="max-h-10" src="/images/nt-logo.svg" alt="Nick Tomlin: Full Stack Engineer"></a> </div> <nav class="header-nav space-x-6 ml-8"> <a href="/" class="hover:underline hover:text-brand-secondary transition-all">Home</a> <a href="/about" class="hover:underline hover:text-brand-secondary transition-all">About</a> <a href="/posts" class="hover:underline hover:text-brand-secondary transition-all">Posts</a> </nav> </div> </header> <main>  <div class="page-content"> <div class="wrapper"> <article itemscope itemtype="http://schema.org/BlogPosting"> <header class="my-4"> <h1 class="lead text-5xl mb-3" itemprop="name headline">VimL Functions</h1> <time datetime="Tue Jul 11 2017 19:00:00 GMT-0500 (Central Daylight Time)" itemprop="datePublished">July 12, 2017</time> </header> <div class="post-content prose lg:prose-xl" itemprop="articleBody"> <p>I’ve started a slow descent into the madness that is VimL. One of the things that I’ve found to be initially confusing is how Vim deals with functions. This may be very obvious to some but It caused me enough head scratching to warrant recording some thoughts here.</p>
<details markdown="1">
  <summary>Cheatsheet</summary>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="vim"><code><span class="line"><span style="color:#6A737D">" All VimL functions must be called</span></span>
<span class="line"><span style="color:#6A737D">" Operations like assignment</span></span>
<span class="line"><span style="color:#6A737D">" or passing to another function or built in</span></span>
<span class="line"><span style="color:#6A737D">" implicitly call a function</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> var </span><span style="color:#F97583">=</span><span style="color:#B392F0"> MyFunc</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#79B8FF">echo</span><span style="color:#B392F0"> MyFunc</span><span style="color:#E1E4E8">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">" Otherwise, you _must_ :call a function</span></span>
<span class="line"><span style="color:#F97583">call</span><span style="color:#B392F0"> MyFunc</span><span style="color:#E1E4E8">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">" You can also store a reference to your function</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> FuncRef </span><span style="color:#F97583">=</span><span style="color:#B392F0"> function</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'MyFunc'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">" and :call it with arguments or pass it to another function</span></span>
<span class="line"><span style="color:#B392F0">call</span><span style="color:#E1E4E8">(FuncRef, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">" Or, stringify and execute it</span></span>
<span class="line"><span style="color:#79B8FF">execute</span><span style="color:#9ECBFF"> 'echo '</span><span style="color:#F97583"> . </span><span style="color:#B392F0">string</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">FuncRef</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">" Bonus: Lambdas (vim8+ and neovim) are pretty swank</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> MyLambda </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> { str -> str</span><span style="color:#F97583"> . </span><span style="color:#9ECBFF">'!'</span><span style="color:#E1E4E8"> }</span></span>
<span class="line"><span style="color:#79B8FF">echo</span><span style="color:#B392F0"> MyLambda</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'yay'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#6A737D">" yay!</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">echo</span><span style="color:#B392F0"> map</span><span style="color:#E1E4E8">([</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">], { _, val -> val * </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8"> })</span></span>
<span class="line"><span style="color:#6A737D">" [2, 4, 6]</span></span></code></pre>
</details>
<h1 id="getting-func-y">Getting func-y</h1>
<p>Having one way to call a function is boring: most languages have a few different ways to invoke a function you or someone you love has defined. Not to be outdone, VimL has some twists of its own related to functions.</p>
<p>Let’s create a very simple function:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="vim"><code><span class="line"><span style="color:#6A737D">" All Viml functions must begin with a capitol letter</span></span>
<span class="line"><span style="color:#F97583">function!</span><span style="color:#B392F0"> Hello</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">name</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#6A737D">  " :wave: Just in case you were wondering</span></span>
<span class="line"><span style="color:#6A737D">  " all named arguments are only available on the magical</span></span>
<span class="line"><span style="color:#6A737D">  " arguments dictionary (a) within the function</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#9ECBFF"> "Hi "</span><span style="color:#F97583"> . </span><span style="color:#E1E4E8">a:name</span><span style="color:#F97583"> . </span><span style="color:#9ECBFF">"!"</span></span>
<span class="line"><span style="color:#F97583">endfunction</span></span></code></pre>
<p>The easiest way to call this function in a script, we could simply assign it to a variable, or pass the result of invoking it to a built in like <code>echo</code>:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="vim"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> greeting </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Hello</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'bob'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#79B8FF">echo</span><span style="color:#E1E4E8"> greeting</span></span>
<span class="line"><span style="color:#6A737D">"Hi Bob!"</span></span>
<span class="line"><span style="color:#79B8FF">echo</span><span style="color:#B392F0"> Hello</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'bob'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#6A737D">"Hi Bob!"</span></span></code></pre>
<p>This makes a <em>lot</em> of sense! We’ve always been told that VimL doesn’t make much sense; it feels good to prove people wrong doesn’t it?</p>
<p>But, let’s say we just want the side effects of a function and do not want to deal with whatever it returns. It’d make sense to do the same thing but just not assign it right?</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="vim"><code><span class="line"><span style="color:#B392F0">MySideEffectFunc</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'some side effecty argument'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">E492: Not an editor </span><span style="color:#F97583">command</span><span style="color:#E1E4E8">: </span><span style="color:#B392F0">MySideEffectFunc</span><span style="color:#E1E4E8">()</span></span></code></pre>
<p>Not so fast! VimL has other ideas; while certain built in commands (like <code>echo</code>) can be invoked, functions cannot simply be called without passing or assigning their value. This is because things like <code>echo Foo()</code> and <code>let x = Foo()</code> implicitly evaluate or call any expression they are handed (in this case, the expression being invoking the function <code>Foo</code>). Since <code>Foo()</code> isn’t good enough, we need a way to tell VimL to actually call the function.</p>
<p>This is where <a href="http://vimdoc.sourceforge.net/htmldoc/eval.html#:call"><code>:call</code></a> steps in. <code>:call</code> calls a function, with up to 20 arguments (because 19 just wasn’t enough), and discards its return value.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="vim"><code><span class="line"><span style="color:#E1E4E8">:</span><span style="color:#F97583">call</span><span style="color:#B392F0"> MySideEffectFunc</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'this wooooorks'</span><span style="color:#E1E4E8">)</span></span></code></pre>
<p>Call is the <em>the</em> way of calling functions within your plugins, or invoking other functions from ex mode.</p>
<h1 id="show-me-your-references">Show me your references</h1>
<p>Let’s explore another way we can use our functions: references. Let’s take a common example, using <a href="http://vimdoc.sourceforge.net/htmldoc/eval.html#map()"><code>map</code></a> with a function we’ve previously defined. We can use Vim’s <code>function</code> keyword to create a funcref (that is a reference to function <em>wink</em> <em>wink</em>) which allows us to pass it to <code>map</code>, <code>filter</code>, or another function.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="vim"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> Exclaim</span><span style="color:#E1E4E8">(idx, name)</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> a:name</span><span style="color:#F97583"> . </span><span style="color:#9ECBFF">"!"</span></span>
<span class="line"><span style="color:#F97583">endfunction</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> greetings </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span><span style="color:#9ECBFF">'Hey'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'Howdy'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'Hi'</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> exclaimed </span><span style="color:#F97583">=</span><span style="color:#B392F0"> map</span><span style="color:#E1E4E8">(greetings, </span><span style="color:#B392F0">function</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'Exclaim'</span><span style="color:#E1E4E8">))</span></span>
<span class="line"><span style="color:#79B8FF">echo</span><span style="color:#E1E4E8"> exclaimed</span></span>
<span class="line"><span style="color:#6A737D">" ['Hey!', 'Howdy!', 'Hi!']</span></span></code></pre>
<p>If we wanted to take a more generic function that did not need to be aware of <code>idx</code>, we could use <code>string</code>ify our funcref and use <code>map</code>’s second argument (a string to be <code>eval</code>d) to invoke our function with the value of each pair we are iterating through:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="vim"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> Exclaim</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">name</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> a:name</span><span style="color:#F97583"> . </span><span style="color:#9ECBFF">"!"</span></span>
<span class="line"><span style="color:#F97583">endfunction</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> greetings </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span><span style="color:#9ECBFF">'Hey'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'Howdy'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'Hi'</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> exclaimed </span><span style="color:#F97583">=</span><span style="color:#B392F0"> map</span><span style="color:#E1E4E8">(greetings, </span><span style="color:#B392F0">string</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">function</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'Exclaim'</span><span style="color:#E1E4E8">))</span><span style="color:#F97583"> . </span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'v:val'</span><span style="color:#E1E4E8">))</span></span>
<span class="line"><span style="color:#79B8FF">echo</span><span style="color:#E1E4E8"> exclaimed</span></span>
<span class="line"><span style="color:#6A737D">" ['Hey!', 'Howdy!', 'Hi!']</span></span></code></pre>
<p>That works, but it’s not very readable. Luckily, more modern versions of Vim have an answer.</p>
<h1 id="lambdas-to-the-rescue">Lambdas to the rescue</h1>
<p>If we, or our intended users, are using vim8+ or neovim, we can use the new lambda syntax to simplify things:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="vim"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> Exclaim</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">name</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> a:name</span><span style="color:#F97583"> . </span><span style="color:#9ECBFF">"!"</span></span>
<span class="line"><span style="color:#F97583">endfunction</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> greetings </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span><span style="color:#9ECBFF">'Hey'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'Howdy'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'Hi'</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> exclaimed </span><span style="color:#F97583">=</span><span style="color:#B392F0"> map</span><span style="color:#E1E4E8">(greetings, {</span><span style="color:#79B8FF">key</span><span style="color:#E1E4E8">, val -> </span><span style="color:#B392F0">Exclaim</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">val</span><span style="color:#E1E4E8">)})</span></span>
<span class="line"><span style="color:#79B8FF">echo</span><span style="color:#E1E4E8"> exclaimed</span></span>
<span class="line"><span style="color:#6A737D">" ['Hey!', 'Howdy!', 'Hi!']</span></span></code></pre>
<p>We can even remove our simple function entirely and perform our string modifications within the Lambda if we want:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="vim"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> greetings </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span><span style="color:#9ECBFF">'Hey'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'Howdy'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'Hi'</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> exclaimed </span><span style="color:#F97583">=</span><span style="color:#B392F0"> map</span><span style="color:#E1E4E8">(greetings, {</span><span style="color:#79B8FF">key</span><span style="color:#E1E4E8">, val -> val</span><span style="color:#F97583"> . </span><span style="color:#9ECBFF">'!'</span><span style="color:#E1E4E8">})</span></span>
<span class="line"><span style="color:#79B8FF">echo</span><span style="color:#E1E4E8"> exclaimed</span></span>
<span class="line"><span style="color:#6A737D">" ['Hey!', 'Howdy!', 'Hi!']</span></span></code></pre>
<h1 id="thats-it">That’s it!</h1>
<p>There’s so much under the hood with VimL but effectively using functions is a great way to get started writing a simple script or plugin to help make your life better. I hope this helps remove some of the confusion that I initially had.</p> </div> <footer class="my-10"> <div> <a href="/posts" class="py-1 px-4 rounded-md bg-brand-primary text-white no-underline">
More posts
</a> </div> <div class="my-4"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="8NoPI" prefix="r1" component-url="/_astro/DisqusComments.9-ilZC2Y.js" component-export="default" renderer-url="/_astro/client.BNKbhxCX.js" props="{&quot;shortname&quot;:[0,&quot;nick-tomlin&quot;],&quot;config&quot;:[0,{&quot;locale&quot;:[0,&quot;en_US&quot;],&quot;identifier&quot;:[0,&quot;/2017/07/12/viml-functions&quot;],&quot;title&quot;:[0,&quot;VimL Functions&quot;]}]}" ssr client="load" opts="{&quot;name&quot;:&quot;DisqusComments&quot;,&quot;value&quot;:true}" await-children><div id="disqus_thread"></div><!--astro:end--></astro-island> </div> </footer> </article> </div> </div>  </main> <!-- Empty footer for now --> </body></html>